# Overview

Here the class from the last example is rewritten using a more advanced 
constructor pattern. This is not something which is expected of beginners, but 
serves to illustrate the expressive power which the Pebble primitives allow.


To recap, 'self' refers to the method/object's own local scope. On the other hand, 
'caller' refers to the method/object which called it (and hence maybe be Nothing). 


This uses an idea specific to Pebble, which is that when a method does not have 
a user-defined return statement, it will either return itself (self) or whatever 
object called it (caller). By default, 'caller' is returned unless it does not exist, 
i.e. it is Nothing. If this is the case, then 'self' is returned.


# Details

First note that the '.' operator is also aliased by the a space (' ') when 
dealing with scoped method calls. This occurs on line [20], which is equivalent 
to 'MyCar.Has().Efficiency(30.0).Fuel(10.0)`. 


Lines [11] and [14] utilize one argument lambda expressions ('(E): ...' and 
'(F): ...') respectively which are assigned to the local Calls       
'self.Efficiency' and 'self.Fuel' respectively. These Calls are local to the scope of the 
'Has' method.


The magic happens with the 'Has()' method call. This is a method which returns 
itself (line [17]) as an object. It has its own 'Efficiency' and 'Fuel' calls 
(again, you can think of Calls as variables) which are methods that populate 
the attributes of a Car.


The specific Car in question is defined on line [9]. It's actually the caller of 
the 'Has' method, which, if we look on line [20], is precisely 'MyCar'. So both 
of the methods of 'Has' are really just populating the attributes of 'MyCar'. 


Overall, this serves as an interesting approach to redesigning the constructor. This 
pattern provides contexual information on the attributes of the object being constructed 
and does not rely on knowing the order of each argument of a constructor as typical 
constructors tend to require. 