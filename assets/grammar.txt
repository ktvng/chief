Documentation: 
    Everything before the first line with leading character ';' is ignored

    The first section defines grammars rules. Individual tokens are separated
    by spaces, and all whitespace is ignored.

    The first line should be formatted
        @ [RuleName] [PrecedenceOperation] [CollapseMethod]

    where:
        [RuleName] is the name of the rule and should correspond to the atomic 
            operation (OperationTypes) expressed by the rule. 

        [PrecedenceOperation] is the operation which defines the precedence 
            class of the rule

        [CollapseMethod] defines how to merge the output of the rule back into 
            the parent operation

    Optional precendence override:
    Following the declaration line, there are the option precedence override lines.
    There lines must begin with either '<' or '>' and contain a list of whitespace
    separated operator tokens. 

    Tokens listed after '>' will be treated as having higher precedence than the current
    rule while tokens listed after '<' will be treated as having lower precedence

    Following these optional lines, the actual production rules can be listed. There
    may be multiple production rules which corresopnd to the same declaration and
    override lines.

    The second line should be formatted
        [ProductionRule] -> ...

    Note: All production rules should begin with an uppercase
    Note: Grammar rules are matched in the order they are listed. Matching is greedy.

Precedence:
    The second section defines precedence classes listed from high to low.
    


------------------------------------------------------------------------------------------------------------------------

;;; Preprocessing
@ <=
is leq to
is leq
leq 
leq to
is less than or equal to

@ >=
is geq to
is geq
geq
geq to
is greater than or equal to

@ ==
equals
is equal
is equal to

@ !=
does not equal
not equal
not equal to
not equals
is not

@ !
not

@ a
an

@ &&
and

@ ||
or

@ here
inherits

@ say
print

@ .
's

@ else
otherwise
ow





;;; Grammar begins here

@ IsEqual == Reduce
Expr -> Expr == Expr
Expr -> Expr == SRef
Expr -> SRef == Expr

@ IsNotEqual != Reduce
Expr -> Expr != Expr
Expr -> Expr != SRef
Expr -> SRef != Expr

@ IsGreaterThan > Reduce
Expr -> Expr > Expr
Expr -> Expr > SRef
Expr -> SRef > Expr

@ IsLessThan < Reduce
Expr -> Expr < Expr
Expr -> Expr < SRef
Expr -> SRef < Expr

@ IsGreaterThanOrEqualTo >= Reduce
Expr -> Expr >= Expr
Expr -> Expr >= SRef
Expr -> SRef >= Expr

@ IsLessThanOrEqualTo <= Reduce
Expr -> Expr <= Expr
Expr -> Expr <= SRef
Expr -> SRef <= Expr

@ Class class Reduce
Class -> a Ref 

@ Class class Retain
Class -> Class ():
Class -> Class :


@ New new Reduce
Expr -> new Ref


@ ScopeResolution . Reduce
> (
SRef -> Expr . Ref
SRef -> SRef . Ref
SRef -> Ref


@ Return = Reduce
Line -> return Expr


@ Add + Reduce
Expr -> Expr + Expr
Expr -> Expr + SRef
Expr -> SRef + Expr

@ Subtract - Reduce
Expr -> Expr - Expr
Expr -> Expr - SRef
Expr -> SRef - Expr

@ Multiply * Reduce
Expr -> Expr * Expr
Expr -> Expr * SRef
Expr -> SRef * Expr

@ Divide / Reduce
Expr -> Expr / Expr
Expr -> Expr / SRef
Expr -> SRef / Expr

@ And && Reduce
Expr -> Expr && Expr
Expr -> Expr && SRef
Expr -> SRef && Expr

@ Or || Reduce
Expr -> Expr || Expr
Expr -> Expr || SRef
Expr -> SRef || Expr

@ Not ! Retain
Expr -> ! Expr


@ Ask lowest Reduce
Expr -> ask Expr

@ Print lowest Reduce
Line -> say Expr



@ EvaluateHere ! Reduce
Expr -> here Expr

@ Evaluate ( ScopedEval
> :
Expr -> SRef . Ref ( )
Expr -> SRef . Ref ( Expr )
Expr -> SRef . Ref ( Tuple )

Expr -> Expr . Ref ( )
Expr -> Expr . Ref ( Expr )
Expr -> Expr . Ref ( Tuple )

Expr -> Class . Ref ( )
Expr -> Class . Ref ( Expr )
Expr -> Class . Ref ( Tuple )

@ Evaluate ( UnscopedEval
> :
Expr -> Ref ( )
Expr -> Ref ( Expr )
Expr -> Ref ( Tuple )


@ Else : Reduce
> if
Line -> else

@ ElseIf : Reduce
Line -> else if Expr

@ If : Reduce
Line -> if Expr


@ While : Reduce
Line -> while Expr

@ For : Reduce
Line -> for each ( Ref in Expr )
Line -> for each Ref in Expr 


@ DefineMethod : Custom
Line -> Ref ( Tuple ) :
Line -> Ref ( Expr ) :
Line -> Ref ( ) :

@ IsEqual == Reduce
Expr -> Expr is Expr

@ Is is Reduce
Expr -> SRef is Expr

@ Assign = Reduce
Line -> SRef = Expr
Line -> SRef = ( Tuple )





@ Tuple , Merge
Tuple -> Tuple , Expr

@ Tuple , Reduce
Tuple -> Expr , Expr


@ NoOperationType ( Retain
Expr -> ( Expr )

@ NoOperationType ! Retain
> = is
Expr -> SRef

@ NoOperationType lowest Retain
Line -> consider Expr
Line -> take Expr
Line -> Expr






;;; Operator Precedence
in new class highest
(
[ .
!
* /
+ -
< > <= >=
== != 
&&
||
= is
,
) :
lowest 




;;; End 
